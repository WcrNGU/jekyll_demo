---
layout: defualt
title: 操作系统复习
category: review
---

# {{page.title}}

## 中断
异步事件指无一定时序关系，或非预期的事件，当发生异步事件时，即产生一个中断。  
中断处理是内核最重要的功能之一，当内核响应一个中断时，屏蔽其它中断，处理完一个中断后，又转而去完成其它内容。 
中断按类型分为：程序中断，软件中断，时钟中断，I/O中断，硬件失效中断。按是否可屏蔽分为：可屏蔽中断和不可屏蔽中断。  
多个中断的处理采用：优先级和乱转法结合，中断执行过程中也可以被更高优先级的中断打断，转而执行其它中断，执行完成后返回。  
中断响应问题：响应时机应为执行完一条指令之后，响应条件应该是CPU没有被禁止，终端源应当被识别才能有效调用执行中断的程序。

## 进程
进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，是系统进行资源分配的一个独立单位。  
进程是动态产生、动态消亡的，每个进程都有一个数据结构————进程控制块（PCB:process control block）记录其执行情况。(linux中称为task_struct)  
进程有三种基本状态，运行、就绪和等待，进程刚进入内存是就绪态，在运行过程中不断变化，这三种状态每种都是一个队列，一系列进程在其中排队。（linux的进程状态有五种）  
线程是进程中的一个实体，不拥有资源，但可以使用进程的资源。一个进程可以有多个线程，一个线程是一个CPU调度单位。  
一个线程可以创建和撤销另一个线程，同一个进程中的多个线程也可以并发执行，不同的线程可以执行同一段程序。   
线程也有运行、就绪、等待三种状态。  
进程是动态的过程，而程序是静态的存储在硬盘上的代码。  
作业调度是程序获得进入内存的机会，进程调度是进程获得CPU时间片的机会。

## 多道程序设计
一个程序在没有执行完成之前，允许其它进程也开始执行，则成为“并发进程”。  
并发执行各进程之间使用的资源称为临界资源（这些资源一次只允许一个进程进入），各进程中涉及到临界资源的程序段称为“临界区”。  
进程互斥：并发进程互斥地进入相关临界区，每次只允许一个进程进入。  
进程同步：进程间的一种协同工作关系，一些进程相互合作完成一项任务。  
实现进程同步和进程互斥的机制统称为“同步机制”。
P、V操作同步机制：S为信号量，大于0时表示可用资源数，等于0表示没有可用资源，不允许程序再进入临界区，小于0时表示等待进入临界区的进程数量。P(S)表示申请一个资源（S-1），进程在使用资源前操作；V(S)表示释放一个资源(S+1)，进程在使用完资源后操作。 
经典的进程同步互斥问题：生产者-消费者问题，读者-写者问题，哲学家就餐问题。 
进程间通信分为三种：共享内存，消息机制（消息缓冲通信，信箱通信），管道通信。  
进程调度算法：先进先出、时间片轮转算法、最高优先级算法、多级队列反馈法。  
操作系统内核功能：中断处理、进程调度、进程控制、进程同步互斥、进程通信、存储管理、设备管理、文件管理、时钟管理。  
假脱机技术（SPOOLing）用磁盘作为主机的输入输出设备，具有专门负责I/O的进程常驻内存，提高了处理器效率，有效防止忙等待。

## 存储管理
CPU访问内存根据绝对地址访问，用户程序访问内存根据逻辑地址访问，将逻辑地址转换为CPU可直接寻址的物理地址的过程称为地址映射。  
分区存储：分为固定分区和可变分区，是一种连续性的管理方案，缺点是容易产生碎片，合并碎片又降低了效率。  
页式存储：以页面为单位，按照请求的内存大小划分相应的页数，页面在逻辑上连续，在物理内存上并不连续。逻辑页面地址采用 逻辑页号+页内地址，linux使用这种存储管理。  
段式存储：以系统划分的大小不一的段为单位分配内存，一个段对应一个过程，一个程序模块或数据集合。逻辑地址采用 段号+段内地址。  
段页式存储：结合段式的逻辑划分和页式的高效低碎片特点，逻辑地址采用 段号+段内地址（页号+页内地址）。  
由于内存大小有限制，而外存大小往往远大于内存，需要采用虚拟存储技术，即将部分数据和程序读入内存，在执行的过程中如果需要新的数据，就向处理器发出一个缺页中断，从外存取得相应的数据，读入内存置换掉原本存在内存的其它数据，典型的页面置换算法有理想页面置换算法（OPT）（淘汰最远要使用的页，无法实现，只是一个指标值）、先进先出置换算法（FIFO）（淘汰先进入内存的页面）、最近最少使用算法（LRU）（淘汰最久未使用的页面）。  

## 死锁
产生死锁的四个条件：
1. 互斥条件，任一时刻一个资源只能给一个进程使用。
2. 不可剥夺，资源只能由占有它的进程主动释放，不能被其它资源抢占。
3. 请求和保持条件，进程每次申请它所需要的一部分资源，在申请新资源的同时，继续占有已经分配到的资源。
4. 循环等待条件，形成一个进程等待环路，互相需要对方拥有的资源。  
条件4蕴含了条件1-3，破环任何一个条件都不能形成死琐。  
解决死锁的四个办法：预防死锁，避免死锁，检测死锁，接触死锁。  
银行家算法（预防死锁）：
1. 顾客需求的资金不超过银行家现有的资金；
2. 顾客可以分期贷款，但总数不能超过需求资金；
3. 当现有资金不能支付顾客尚需的贷款数额时，顾客等待，但总能使顾客在有限时间内得到贷款；
4. 顾客一定能在有限时间内归还所有资金。